# 11장 원시 값과 객체의 비교

## 요약

- 데이터 타입은 크게 원시타입, 객체타입으로 구분
- 원시타입은 변경불가능, 객체타입은 변경가능
- 원시 값을 변수에 할당하면 변수에는 실제 값이 저장, 객체를 변수에 할당하면 변수에는 참조값이 저장
- 원시값을 갖는 변수를 다른 변수에 할당하면 원시 값이 복사됨 -> 값에 의한 전달
- 객체의 경우는 다른 변수에 할당하면 참조 값이 복사됨 -> 참조에 의한 전달

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

- 읽기전용으로 변경이 불가 <br>
  cf) 변수는 언제든지 재할당을 통해 변수 값을 변경할 수 있으며, 상수는 재할당이 금지된 변수임
- 하지만 이때, const 키워드로 사용해 선언한 변수에 할당한 객체는 변경이 가능하다....!!!
- 불변성: 원시값을 변경 불가능해 직접 변경이 불가능하여 재할당을 통해 새로운 메모리 공간을 확보한 후 재할당한 값을 저장하여 변수가 참조하던 메모리 공간의 주소를 변경함!

### 11.1.2 문자열 불변성

- 문자열은 유사배열객체이면서 이터러블임
- 유사배열객체: 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있으며 length 프로퍼티를 갖는 객체, for문으로 순회도 가능
- 원시값인 문자열이 객체처럼 사용되면 원시값을 감싸는 래퍼객체로 자동 변환됨
- 문자열 또한 변경이 불가능
- 재할당을 통해 새로운 메모리공간 확보해서 참조를 변경해야 함

### 11.1.3 값에 의한 전달

- 값에 의한 전달: 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달

  ```javascript
  var score = 80;
  var copy = score; // 값이 전달됨

  console.log(score, copy); // 80 80
  console.log(score === copy); // true

  // score변수와 copy의 다른 메모리 공간을 가지고 있어서 영향을 서로 주지 않음
  score = 100; // copy 80
  ```

- 엄격히 말하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달 -> 식별자는 값이 아니라 주소를 기억하기 때문
- 값에 의한 전달도 사실은 메모리 주소를 전달하는 것임 -> 전달된 메모리 주소로 메모리 공간을 접근하면 값을 참조 가능해짐

## 11.2 객체

- 프로퍼티 개수가 정해져 있지 않으며 동적으로 추가, 삭제가 가능해져 메모리 공간의 크기를 사전에 정해 둘 수 없음

### 11.2.1 변경 가능한 값

- 객체(참조)타입의 값, 즉 객체는 변경 가능한 값
- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근
- 참조 값은 생성된 객체가 저장된 메모리 공간의 주소!
- 객체를 할당한 변수를 참조하면 참조 값을 통해 실제 객체에 접근
- 원시값과 달리 재할당없이 프로퍼티를 동적으로 추가할 수 있고 프로퍼티 값을 갱신할 수도 있고 프로퍼티 자체를 삭제할 수 있음
- 객체는 변경 가능한 값이므로 메모리 저장된 객체를 직접 수정할 수 있음
- 변수에 재할당하지 않는 한 같은 참조값을 가리킴
- 여러 개 식별자가 하나의 객체를 공유할 수 있음 <br>

cf) 얕은 복사 vs 깊은 복사 <br>

- 얕은 복사는 한 단계까지만 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사
- 얕은 복사와 깊은 복사로 생성된 객체는 원본과 다른 객체이므로 원본과 복사본은 참조 값이 다른 별개의 객체

### 11.2.2 참조에 의한 전달

- 할당하면 참조 값이 복사되어 전달되므로 참조에 의한 전달이라고 함

```javascript
var person = {
  name: "Lee",
};

var copy = person; // 얕은 복사

console.log(person === copy); // true: 동일한 객체 참조
copy.name = "Kim";
person.address = "Seoul";

// 서로 영향을 받음
console.log(person); // {name: "Kim", address:"Seoul"}
console.log(copy); // {name: "Kim", address:"Seoul"}
```

```javascript
var person1 = {
  name = 'Lee'
};

var person2 = {
  name = 'Lee'
};

console.log(person1===person2); // false
console.log(person1.name===person2.name); //true
```

- 객체 리터럴은 평가될 때마다 객체를 생성
- 각 가리키는 객체는 비록 내용은 같지만 다른 메모리에 저장된 별개의 객체
- 프로퍼티 값을 참조하는 각 name은 원시값으로 평가되어 비교해서 true가 나옴
